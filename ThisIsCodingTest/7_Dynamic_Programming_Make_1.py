

# 실전문제 1. 1로 만들기
# 정수 x가 주어질때 정수 x에 사용할 수 있는 연산은 다음과 같다
# 1. x가 5로 나누어 떨어질때 5로 나눈다.
# 2. x가 3로 나누어 떨어질때 3로 나눈다.
# 3. x가 2로 나누어 떨어질때 2로 나눈다.
# 4. x에서 1을 뺀다.

# 위의 연산을 사용하여 주어진 숫자를 1로 만들때, 연산을 사용하는 횟수의 최솟값을 출력

n = int(input("입력 : "))
count = 0
while n != 1:
    if (n%5 == 0):
        n /= 5
        count += 1
    elif (n%3 == 0):
        n /= 3
        count += 1
    elif (n%2 == 0):
        n /= 2
        count += 1
    else:
        n -= 1

print(n, count)
# 나의 답안의 문제점 : 최솟값을 적절하게 고려하지 못함


# 답안
# 예를들어 19이 주어졌을때
# 방법 1 -> 19-1, 18/3, 6/3, 2/2
# 방법 2 -> 19-1, 18/3, 6/3, 2-1
# 방법 3 -> 19-1, 18/3, 6/2, 3/3
# 방법 4 -> 19-1, 18/3, 6/2, 3-1, 2/2
# 방법 5 -> 19-1, 18/3, 6/2, 3-1, 2-1
# ...
# -> 최적의 방법을 찾아야함


n = int(input("입력 : "))
d = [0]*30001

d[1] = 1
for i in range(2, n):
    # 1을 뺀 경우
    d[i] = d[i-1] + 1
    # 2를 나눈 경우
    if i % 2 == 0:
       d[i] = min(d[i], d[i//2]+1)
    # 3을 나눈 경우
    if i % 3 == 0:
       d[i] = min(d[i], d[i//2]+1) 
    # 5를 나눈 경우
    if i % 5 == 0:
       d[i] = min(d[i], d[i//2]+1)

print(d[n])  

# 아이디어 -> 바텀업, 아래에서 부터 1로 만들기위한 제일 작은 경우의 수를 찾고
# 그 수에 더하는 방식
# elif 안쓰는 이유 -> 2,3,5로 나눴을때 중 최고로 작은 경우를 찾음.