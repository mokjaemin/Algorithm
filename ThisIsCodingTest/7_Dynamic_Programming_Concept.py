

# 다이나믹 프로그래밍
# 배경 : 컴퓨터의 메모리공간 제약, 속도 제한으로 컴퓨터가 못푸는 문제 존재.
# 메모리 공간을 약간 더 사용하면 연산속도를 비약적으로 증가시킬 수 있는 방법

# 설명
# 1. 기본적인 아이디어
# 2. 2가지 방식 - 탑다운, 보텀업
# 3. 메모이제이션 기법


# 예제 1
# 피보나치 수열
# a(n+2) = a(n+1) + a(n) (a(1)=1, a(2)=2)


# 내가 작성
# arr = []
# def fibo(x):
#     arr.append(arr[x-1] + arr[x-2])
#     print(arr)

# arr.append(1)
# arr.append(1)
# fibo(2)
# fibo(3)

# 답안
# def pibo(x):
#     if x == 1 or x == 2:
#         return 1
#     return pibo(x-1) + pibo(x-2)
# print(pibo(4))

# 위 코드의 문제점
# n이 커질수록 수행시간이 기하급수적으로 증가
# 시간 복잡도 : O(2**n)


# 다이나믹 프로그래밍 사용 조건
# 1. 큰 문제를 작은 문제로 나눌 수 있다
# 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
# -> 큰문제를 작은 문제로 나누고 같은 문제라면 한번씩만 풀어 문제를 효율적으로 해결하는 알고리즘

# 메모이제이션 기법
# 정의 : 다이나믹 프로그래밍을 구현하는 방법 중 하나로 한 번 구한 결과를 메모리 공간에 메모해두고
# 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
# 캐싱 : 메모제이션이 값을 저장하는 방법
# 구현 : 한번 구한 정보를 리스트에 담는다.


# 답안
# d = [0]*100

# def pibo(x):
#     # 1 또는 2인 경우
#     if x == 1 or x == 2:
#         return 1
#     # 이미 계산한 적이 있는 경우
#     if d[x] != 0:
#         return d[x]
#     # 아직 계산한적이 없는 경우
#     d[x] = fibo(x-1) + fibo(x-2)
#     return d[x]

# print(pibo(99))



# 재귀함수대신에 반복문을 사용하자.
# 재귀함수 사용시 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을
# 따라야 하므로 오버헤드 발생 -> 오버헤드를 줄이려면 반복문 사용한다.
# 적용시 시간복잡도 -> O(N)


# 호출되는 함수 확인 (재귀함수)
# 큰 문제를 위해 작은 문제를 호출한다 -> 탑다운, 하향식
# d = [0]*100 // 메모이제이션

# def pibo(x):
#     print('f(' + str(x) + ')', end=' ')
#     # 1 또는 2인 경우
#     if x == 1 or x == 2:
#         return 1
#     # 이미 계산한 적이 있는 경우
#     if d[x] != 0:
#         return d[x]
#     # 아직 계산한적이 없는 경우
#     d[x] = pibo(x-1) + pibo(x-2)
#     return d[x]
# pibo(6)


# 반복문 이용
# 작은 문제부터 차근차근 답을 도출 -> 보텀업, 상향식
# 아래에서 위로 올라가는 방법

d = [0]*100 # DP테이블(결과 저장용 리스트)
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])

# 메모이제이션, DP테이블은 다른 개념

# 문제 풀이
# 1. 주어진 문제가 다이나믹 프로그래밍 유형인지 파악하자!
# -> 완전 탐색 알고리즘으로 접근시 시간이 매우 오래걸린다면
# 2. 메모이제이션을 이용하자!
# 3. 웬만하면 보텀업을 사용하자!